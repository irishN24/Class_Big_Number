// Operator /= with Big_Number
Big_Number& operator /=(const Big_Number &v) {
    *this = *this / v;  // Use existing division operator
    return *this;
}

// Fixed Big_Number division operator
Big_Number operator /(const Big_Number &v) {
    // Check for division by zero
    if (v.len == 1 && v.coef[0] == 0) {
        throw invalid_argument("Division by zero!");
    }
    
    // If dividend < divisor, result is 0
    if (*this < v) {
        Big_Number res0(1);
        res0.coef[0] = 0;
        return res0;
    }
    
    // If divisor is single digit, use simpler division
    if (v.len == 1) {
        return *this / v.coef[0];
    }
    
    // Multi-precision division using long division algorithm
    Big_Number dividend = *this;
    Big_Number divisor = v;
    Big_Number quotient(dividend.len + 1);
    Big_Number remainder(1);
    
    // Initialize quotient and remainder to zero
    for (int i = 0; i < quotient.maxlen; i++) {
        quotient.coef[i] = 0;
    }
    quotient.len = 1;
    remainder.coef[0] = 0;
    
    // Perform long division from most significant digit
    for (int i = dividend.len - 1; i >= 0; i--) {
        // Shift remainder left by one base position and add current digit
        remainder *= ((D_Base)1 << BASE_SIZE);
        remainder += Big_Number(dividend.coef[i]);
        
        // Find how many times divisor fits into current remainder
        Base digit = 0;
        while (remainder >= divisor) {
            remainder -= divisor;
            digit++;
        }
        
        // Store digit in quotient
        quotient.coef[i] = digit;
        if (digit > 0 && quotient.len <= i) {
            quotient.len = i + 1;
        }
    }
    
    // Remove leading zeros from quotient
    while (quotient.len > 1 && quotient.coef[quotient.len - 1] == 0) {
        quotient.len--;
    }
    
    return quotient;
}

// Operator % with Big_Number (modulo)
Big_Number operator %(const Big_Number &v) {
    // Check for division by zero
    if (v.len == 1 && v.coef[0] == 0) {
        throw invalid_argument("Division by zero in modulo operation!");
    }
    
    // If dividend < divisor, remainder is dividend itself
    if (*this < v) {
        return *this;
    }
    
    // If divisor is single digit, use simpler modulo
    if (v.len == 1) {
        return *this % v.coef[0];
    }
    
    // Use division to calculate remainder: a % b = a - (a / b) * b
    Big_Number quotient = *this / v;
    Big_Number product = quotient * v;
    Big_Number remainder = *this - product;
    
    return remainder;
}

// Operator %= with Big_Number
Big_Number& operator %=(const Big_Number &v) {
    *this = *this % v;  // Use existing modulo operator
    return *this;
}
